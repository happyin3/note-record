## PEP 227 静态嵌套作用域

[PEP 227 -- Statically Nested Scopes](https://www.python.org/dev/peps/pep-0227/)

### 摘要

这个PEP（Python Enhancement Proposals，Python增强提案）用于说明在Python 2.2中新增了静态嵌套作用域（词法作用域）的特性，并且在Python 2.1中提供了一个有关这个特性是否启用的源码级别的选项。在Python 2.1中启用这个特性时，针对有影响的程序结构解释器会给出警告信息。

在2.0和之前的版本中，Python定义了三类命名空间来解析变量——局部、全局和内建的命名空间。静态嵌套作用域解决了在封闭的函数中未绑定的局部变量的解析问题。

静态嵌套作用域带来的最显而易见的影响就是lambda表达式可以引用定义在`surrounding namespace`中的变量。目前（Python 2.1之前），lambda表达式在lambda表达式的命名空间中只能通过使用默认值的方式来明确的创建变量绑定。

### 引言

这个提案改变了函数中自由变量的解析规则。新的变量解析语法规则会在Python 2.2中生效。在Python 2.1中，可以通过在模块的顶部导入`from __future__ import nested_scopes`来获取这个特性。（阅读[PEP 236](https://www.python.org/dev/peps/pep-0236/)）

Python 2.0定义了三个命名空间——局部命名空间、全局命名空间、内置命名空间。根据以上定义，如果函数A定义在函数B中，则定义在函数B中的变量对函数A就不可见。这个提案修改了解析规则，从而使得函数B中的变量在函数A中可见（除非函数A中定义了相同名称的变量，隐藏了函数B中的变量）。

这个规范引入的词法作用域的规则和类Algol语言相似。一等函数和词法作用域的组合让人想起了Scheme语言。

作用域规则的改变解决了两个问题——lambda表达式（嵌套函数）有限的作用、一些习惯了支持嵌套词法作用域语言的新用户的疑惑（不能定义除模块级别外的递归函数）。

lambda表达式返回一个匿名函数。经常用作回调函数。在以下的例子中（Python 2.0环境），在lambda中使用的变量都必须通过传递一个默认值来赋值。

    from Tkinter import *
    root = Tk()
    Button(root, text="Click here",
        command=lambda root=root: root.test.configure(text="..."))

这种方法很麻烦，尤其是当需要很多变量时。超长的默认参数列表模糊了代码的目的。嵌套作用域方案可以认为是自动的给变量绑定了默认参数，就不需要再这样`root=root`手动的绑定。

新的变量解析语法也导致了一些问题。在原先使用Python 2.0的代码中，在Python 2.2之后，可能会编译出错。或者在嵌套函数中，原先解析为全局变量的，现在可能解析程非局部变量（即嵌套变量），导致一些奇怪的问题。在Python 2.1中，编译器会给出所有异常警告信息。

### 规范

Python是一种基于块结构的静态作用域语言，类似早期的Algol。代码块或区域是代码的基本单元，有模块、类、函数体等。

名称指向对象。
